<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Task Manager Flow</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #111; color: #eee; font-family: sans-serif; overflow: hidden; }
        #mynetwork { width: 100vw; height: 100vh; }
        #stats {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;
            pointer-events: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 18px; color: #00bcd4; }
        .stat-item { margin-bottom: 5px; font-size: 14px; }
        .log-panel {
            position: absolute; bottom: 10px; left: 10px; width: 400px; height: 150px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;
            font-family: monospace; font-size: 12px; overflow-y: auto;
        }
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #333; }
        .log-time { color: #888; margin-right: 5px; }
        #node-details {
            position: absolute; top: 10px; right: 10px; width: 300px;
            background: rgba(0,0,0,0.8); border: 1px solid #444; border-radius: 5px;
            padding: 15px; color: #eee; font-family: sans-serif; display: none;
        }
        #node-details h2 { margin-top: 0; color: #00bcd4; font-size: 16px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        #node-details p { font-size: 13px; line-height: 1.4; color: #ccc; margin-bottom: 15px; }
        .nd-stat-row { display: flex; justify-content: space-between; font-size: 13px; margin-top: 5px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .nd-stat-val { font-weight: bold; color: #fff; }
    </style>
</head>
<body>

<div id="node-details">
    <h2 id="nd-title">Node Details</h2>
    <p id="nd-desc">Select a node to view details.</p>
    <div id="nd-stats"></div>
</div>

<div id="stats">
    <h1>System Stats</h1>
    <div id="msg-rate" class="stat-item">Events/sec: 0</div>
    <div id="total-tasks" class="stat-item">Total Tasks: 0</div>
    <div id="active-tasks" class="stat-item">Active Tasks: 0</div>
</div>

<div id="log-panel" class="log-panel"></div>
<div id="mynetwork"></div>

<script type="text/javascript">
    // --- Topology Definition ---
    const nodes = new vis.DataSet([
        { id: 'client', label: 'Client\n(Producer)', shape: 'ellipse', color: '#673ab7', font: {color:'#fff'} },
        { id: 'gateway', label: 'Gateway\n(gRPC)', shape: 'hexagon', color: '#4caf50', font: {color:'#fff'} },
        { id: 'ingest', label: 'Ingest', shape: 'box', color: '#ff9800', font: {color:'#fff'} },
        { id: 'enricher', label: 'Enricher', shape: 'ellipse', color: '#9c27b0', font: {color:'#fff'} },
        { id: 'scheduler', label: 'Scheduler', shape: 'box', color: '#2196f3', font: {color:'#fff'} },
        { id: 'worker', label: 'Worker Pool', shape: 'database', color: '#e91e63', font: {color:'#fff'} },
        { id: 'result-store', label: 'Result Store', shape: 'database', color: '#00bcd4', font: {color:'#fff'} },
        { id: 'notifier', label: 'Notifier', shape: 'box', color: '#607d8b', font: {color:'#fff'} },
        { id: 'audit', label: 'Audit', shape: 'box', color: '#795548', font: {color:'#fff'} },
        { id: 'deadletter', label: 'DeadLetter', shape: 'box', color: '#f44336', font: {color:'#fff'} },
        { id: 'redis', label: 'Redis\n(Persistence)', shape: 'database', color: '#d32f2f', font: {color:'#fff'} }
    ]);

    const edges = new vis.DataSet([
        // Logical Flows
        { id: 'e-cl-gw', from: 'client', to: 'gateway', arrows: 'to', length: 250, label: 'Submit Task' },
        { id: 'e-gw-cl', from: 'gateway', to: 'client', arrows: 'to', dashes: true, color: {color:'#bbb'}, label: 'Status Stream' },

        { id: 'e-gw-in', from: 'gateway', to: 'ingest', arrows: 'to', length: 200 },
        { id: 'e-in-en', from: 'ingest', to: 'enricher', arrows: 'to,from', dashes: true, label: 'HTTP' },
        { id: 'e-in-sc', from: 'ingest', to: 'scheduler', arrows: 'to', length: 200 },
        { id: 'e-sc-wk', from: 'scheduler', to: 'worker', arrows: 'to', length: 200, label: 'Priority Queues' },

        { id: 'e-wk-rs', from: 'worker', to: 'result-store', arrows: 'to' },
        { id: 'e-rs-rd', from: 'result-store', to: 'redis', arrows: 'to', dashes: true, color: {color:'#aaa'} },

        // Notifier Flow (Status)
        // Worker/Ingest -> Notifier -> Redis -> Gateway -> Client
        { id: 'e-wk-nt', from: 'worker', to: 'notifier', arrows: 'to', dashes: true, color: {color: '#607d8b'} },
        { id: 'e-in-nt', from: 'ingest', to: 'notifier', arrows: 'to', dashes: true, color: {color: '#607d8b', opacity: 0.3} },
        { id: 'e-en-nt', from: 'enricher', to: 'notifier', arrows: 'to', dashes: true, color: {color: '#607d8b', opacity: 0.3} },
        { id: 'e-nt-rd', from: 'notifier', to: 'redis', arrows: 'to', dashes: true, color: {color: '#607d8b'} },
        { id: 'e-rd-gw', from: 'redis', to: 'gateway', arrows: 'to', dashes: true, color: {color: '#607d8b'} },

        // Audit taps everything
        { id: 'e-wk-au', from: 'worker', to: 'audit', arrows: 'to', color: {color:'#555', opacity:0.3}, dashes: true },
        { id: 'e-gw-au', from: 'gateway', to: 'audit', arrows: 'to', color: {color:'#555', opacity:0.3}, dashes: true },
        { id: 'e-au-rd', from: 'audit', to: 'redis', arrows: 'to', dashes: true, color: {color: '#795548'} },

        // Deadletter
        { id: 'e-wk-dl', from: 'worker', to: 'deadletter', arrows: 'to', color: {color:'#f44336'}, dashes: true },
        { id: 'e-dl-rd', from: 'deadletter', to: 'redis', arrows: 'to', dashes: true, color: {color:'#f44336'} }
    ]);

    const container = document.getElementById('mynetwork');
    const data = { nodes: nodes, edges: edges };
    const options = {
        physics: {
            stabilization: false,
            barnesHut: { gravitationalConstant: -8000, springConstant: 0.04, springLength: 95 }
        },
        interaction: { hover: true },
        nodes: { shadow: true },
        edges: { width: 2, shadow: true, smooth: { type: 'dynamic' } }
    };
    const network = new vis.Network(container, data, options);

    // --- Node Metadata ---
    const nodeInfo = {
        'client': { title: 'Client (Producer)', description: 'Generates and sends tasks to the system. Represents external users or systems.' },
        'gateway': { title: 'API Gateway', description: 'Entry point for the system. Exposes gRPC endpoints and forwards requests to the Ingest service.' },
        'ingest': { title: 'Ingest Service', description: 'Validates incoming tasks, checks allow-lists, and publishes valid tasks to the pipeline.' },
        'enricher': { title: 'Data Enricher', description: 'Analyzes tasks to assign priority scores (High/Medium/Low) based on URL characteristics.' },
        'scheduler': { title: 'Job Scheduler', description: 'Routes tasks to specific NATS subjects (queues) based on the priority assigned by the Enricher.' },
        'worker': { title: 'Worker Pool', description: 'Executes the core logic. Consumes tasks, performs HTTP checks, and generates results.' },
        'result-store': { title: 'Result Store', description: 'Persists the final outcome of tasks (HTTP Status, Duration) to the database.' },
        'notifier': { title: 'Notification Service', description: 'Listens for task completion events and broadcasts updates to clients via the Gateway.' },
        'audit': { title: 'Audit Log', description: 'Observability component that taps into all events to create a compliance trail.' },
        'deadletter': { title: 'Dead Letter Queue', description: 'Captures malformed or failed messages to ensure system stability and allow for debugging.' },
        'redis': { title: 'Redis (Persistence)', description: 'Key-Value store used for persisting task state, results, queues, and event logs.' }
    };

    const nodeStats = {};
    // Initialize stats
    nodes.getIds().forEach(id => {
        nodeStats[id] = { processed: 0, lastActive: null };
    });
    let currentSelectedNode = null;

    network.on("click", function (params) {
        if (params.nodes.length > 0) {
            currentSelectedNode = params.nodes[0];
            showNodeDetails(currentSelectedNode);
        } else {
            currentSelectedNode = null;
            document.getElementById('node-details').style.display = 'none';
        }
    });

    // --- State & Logic ---
    let eventCount = 0;
    let totalTasks = 0;
    let activeTasks = 0;
    let lastSecondEvents = 0;

    setInterval(() => {
        document.getElementById('msg-rate').innerText = `Events/sec: ${eventCount - lastSecondEvents}`;
        lastSecondEvents = eventCount;
        updateNodeStatsUI();
    }, 1000);

    function log(msg) {
        const p = document.getElementById('log-panel');
        const div = document.createElement('div');
        div.className = 'log-entry';
        div.innerHTML = `<span class="log-time">${new Date().toLocaleTimeString()}</span> ${msg}`;
        p.appendChild(div);
        p.scrollTop = p.scrollHeight;
        if (p.children.length > 50) p.removeChild(p.children[0]);
    }

    // --- WebSocket ---
    const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const socket = new WebSocket(`${wsProtocol}//${location.host}/ws`);

    socket.onopen = () => {
        log("Connected to System Bus");
    };

    socket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        eventCount++;
        handleMessage(msg);
    };

    socket.onclose = () => {
        log("Disconnected. Reconnecting...");
        setTimeout(() => location.reload(), 3000);
    };

    function handleMessage(msg) {
        const subject = msg.subject;
        const payload = msg.data;

        // Visual "packet" animation logic
        if (subject === 'tasks.ingest') {
            animateTraffic('client', 'gateway');
            setTimeout(() => animateTraffic('gateway', 'ingest'), 150);
            totalTasks++;
            activeTasks++;
            updateStats();
            incrementNodeStat('client');
            incrementNodeStat('gateway');
            incrementNodeStat('ingest');
        } else if (subject === 'tasks.schedule') {
            animateTraffic('ingest', 'scheduler');
            incrementNodeStat('scheduler');
        } else if (subject.startsWith('tasks.worker')) {
            animateTraffic('scheduler', 'worker');
            incrementNodeStat('worker');
        } else if (subject === 'tasks.results') {
            animateTraffic('worker', 'result-store');
            setTimeout(() => animateTraffic('result-store', 'redis'), 150);
            activeTasks = Math.max(0, activeTasks - 1);
            updateStats();
            incrementNodeStat('worker');
            incrementNodeStat('result-store');
            incrementNodeStat('redis');
        } else if (subject === 'events.status') {
            // Logic: Source -> Notifier -> Redis -> Gateway -> Client
            const source = mapSourceToNode(payload.source);

            animateTraffic(source, 'notifier');
            setTimeout(() => animateTraffic('notifier', 'redis'), 150);
            setTimeout(() => animateTraffic('redis', 'gateway'), 300);
            setTimeout(() => animateTraffic('gateway', 'client'), 450);
            incrementNodeStat('notifier');
            incrementNodeStat('redis');
            incrementNodeStat('gateway');
            incrementNodeStat('client');

            if (payload && payload.status === 'ENRICHED') {
                animateTraffic('ingest', 'enricher');
                setTimeout(() => animateTraffic('enricher', 'ingest'), 200);
                incrementNodeStat('enricher');
            }
            if (payload && payload.status === 'FAILED') {
                activeTasks = Math.max(0, activeTasks - 1);
                updateStats();
                flashNode(source, '#f44336');
            }
        } else if (subject === 'events.audit') {
            // Logic: Source -> Audit -> Redis
            let source = 'worker'; // default
            if (payload && payload.source) {
                source = mapSourceToNode(payload.source);
            }
            animateTraffic(source, 'audit');
            setTimeout(() => animateTraffic('audit', 'redis'), 150);
            incrementNodeStat('audit');
            incrementNodeStat('redis');

        } else if (subject === 'events.deadletter') {
             // Logic: Source -> Deadletter -> Redis
             animateTraffic('worker', 'deadletter');
             setTimeout(() => animateTraffic('deadletter', 'redis'), 150);
             incrementNodeStat('deadletter');
             incrementNodeStat('redis');
        }
    }

    function updateStats() {
        document.getElementById('total-tasks').innerText = `Total Tasks: ${totalTasks}`;
        document.getElementById('active-tasks').innerText = `Active Tasks: ${activeTasks}`;
    }

    function mapSourceToNode(source) {
        if (!source) return 'worker';
        if (source === 'gateway') return 'gateway';
        if (source.toLowerCase().includes('worker')) return 'worker';
        if (source.toLowerCase().includes('ingest')) return 'ingest';
        return source;
    }

    function animateTraffic(fromId, toId) {
        // Find edge between them
        const edgeIds = edges.get({
            filter: function (item) {
                return (item.from === fromId && item.to === toId) || (item.from === toId && item.to === fromId); // Bi-directional search
            }
        });

        if (edgeIds.length > 0) {
            const edgeId = edgeIds[0].id;
            const originalWidth = edges.get(edgeId).width || 2;
            const originalColor = edges.get(edgeId).color || {color:'#848484'};

            // If it's the reverse direction (to -> from), we might want to animate differently,
            // but for now just flashing the edge is sufficient.

            edges.update({id: edgeId, width: 5, color: {color: '#ffff00'}});
            setTimeout(() => {
                edges.update({id: edgeId, width: originalWidth, color: originalColor});
            }, 300);
        } else {
             // If no direct edge exists (e.g. Ingest -> Notifier directly?), maybe don't animate or log it.
             // With the current graph, we should have edges for all mapped flows.
        }
    }

    function flashNode(nodeId, color) {
        if (!nodes.get(nodeId)) return;
        const originalColor = nodes.get(nodeId).color;
        nodes.update({id: nodeId, color: color});
        setTimeout(() => {
            nodes.update({id: nodeId, color: originalColor});
        }, 500);
    }

    function incrementNodeStat(id) {
        if (nodeStats[id]) {
            nodeStats[id].processed++;
            nodeStats[id].lastActive = new Date();
        }
    }

    function showNodeDetails(nodeId) {
        const info = nodeInfo[nodeId];
        if (!info) return;

        currentSelectedNode = nodeId;
        const panel = document.getElementById('node-details');
        document.getElementById('nd-title').innerText = info.title;
        document.getElementById('nd-desc').innerText = info.description;

        updateNodeStatsUI();
        panel.style.display = 'block';
    }

    function updateNodeStatsUI() {
        if (!currentSelectedNode) return;
        const stats = nodeStats[currentSelectedNode];
        const panelStats = document.getElementById('nd-stats');

        let lastActiveStr = 'Never';
        if (stats.lastActive) {
            const diff = Math.floor((new Date() - stats.lastActive) / 1000);
            lastActiveStr = diff + 's ago';
            if (diff === 0) lastActiveStr = 'Just now';
        }

        panelStats.innerHTML = `
            <div class="nd-stat-row"><span class="nd-stat-lbl">Processed:</span> <span class="nd-stat-val">${stats.processed}</span></div>
            <div class="nd-stat-row"><span class="nd-stat-lbl">Last Active:</span> <span class="nd-stat-val">${lastActiveStr}</span></div>
        `;
    }

</script>
</body>
</html>
